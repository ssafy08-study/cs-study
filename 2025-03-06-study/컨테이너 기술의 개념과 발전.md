# ❇️ 가상화, 컨테이너 기술의 개념과 발전 : 컨테이너를 중심으로

## 1. 컨테이너 vs 가상화
> **컨테이너(Container)** 는 애플리케이션과 그 실행에 필요한 모든 환경(라이브러리, 종속성 등)을 패키징하여 어디서든 일관된 실행 환경을 제공하는 기술

> **가상화(Virtualization)** 는 하드웨어 또는 소프트웨어 리소스를 추상화하여 하나의 물리적 시스템에서 여러 개의 독립적인 환경(운영체제, 애플리케이션 등)을 실행할 수 있도록 하는 기술

<br />

| **특징** | **컨테이너 (Container)** | **가상 머신 (Virtual Machine, VM)** |
|----------|-------------------------|----------------------------------|
| **실행 환경** | OS 커널 공유, 프로세스 수준 격리 | 하드웨어 가상화, OS 단위 격리 |
| **리소스 사용** | 경량, 빠른 실행 (초 단위) | 무겁고, 실행 속도 느림 (분 단위) |
| **배포 방식** | 하나의 OS에서 여러 컨테이너 실행 | 하이퍼바이저 위에서 여러 VM 실행 |
| **이식성** | 높은 이식성 (어디서든 동일 실행 가능) | VM 간의 마이그레이션 가능하지만 무거움 |
| **보안 격리** | 프로세스 단위 격리 (완벽한 격리 아님) | 독립된 OS 실행으로 보안성 높음 |

<br />

컨테이너는 **운영 체제(OS) 커널을 공유하면서 독립적으로 실행**되며, 가상 머신(VM)보다 **가벼운 오버헤드와 빠른 실행 속도**를 가지기에 배포와 확장에 유리. 
단, 강력한 격리, 다양한 OS 지원, 보안, 레거시 시스템 호환성 등에서는 여전히 가상화(VM)가 더 유리한 점이 많음. 특히 금융, 의료, 보안이 중요한 환경에서는 가상머신이 여전히 널리 사용.

---

<br />

## 2. 컨테이너 기술의 발전 과정

### (1) 초창기: 프로세스 격리 기술의 시작
컨테이너의 개념은 **1970년대~1990년대**에 등장한 프로세스 격리 기술에서 시작

- **1979년 UNIX chroot (Change Root)**
  - BSD UNIX에서 처음 도입
  - 특정 프로세스를 별도의 디렉터리로 격리하는 기능을 제공

- **2000년대 초반 FreeBSD Jail, Solaris Zones**
  - **FreeBSD Jail (2000)**: 하나의 OS에서 여러 독립적인 환경을 실행할 수 있도록 함
  - **Solaris Zones (2005)**: 여러 개의 가상 환경을 실행할 수 있도록 OS 수준에서 격리

### (2) 리눅스 컨테이너의 등장 (LXC)

- **2008년 LXC (Linux Containers)**
  - 리눅스 커널에서 `cgroups`와 `namespaces` 기능을 활용하여 프로세스 격리 가능
  - 초창기에는 설정이 복잡하고 사용자 친화적이지 않았음

### (3) 도커(Docker)의 혁신 (2013년~현재)
2013년, **Docker가 등장하면서 컨테이너 기술이 대중화**

- **도커의 핵심 기술**
  - LXC 기반에서 발전한 **Docker Engine** 사용
  - 컨테이너 이미지를 손쉽게 관리할 수 있는 **Docker Hub** 제공
  - 코드 한 줄로 컨테이너 실행이 가능하여 개발자 경험(DevEx)이 대폭 향상

이후, 도커는 **OCI(Open Container Initiative) 표준**을 확립하고, 컨테이너 기술이 클라우드 환경에서 빠르게 확산

### (4) 컨테이너 오케스트레이션과 Kubernetes (2015년~현재)
컨테이너가 대규모 환경에서 사용되면서 **자동화된 컨테이너 관리 시스템(오케스트레이션 툴)**이 필요해짐

- **Google이 Kubernetes(K8s)를 오픈소스로 공개 (2015)**
  - 컨테이너 배포, 확장, 로드 밸런싱, 자동 복구 등을 지원
  - 현재 AWS, GCP, Azure 등 클라우드 환경에서 표준 기술로 자리잡음

이 외에도 **Docker Swarm, Apache Mesos, OpenShift** 등이 존재하지만, Kubernetes가 가장 널리 사용.

---

<br />

## 3. 컨테이너 기술이 중요한 이유

### 컨테이너의 주요 특징
- **경량성**: 하이퍼바이저 없이 OS 커널을 공유하여 가볍고 빠르게 실행 가능
- **이식성**: 개발 환경과 운영 환경 간의 차이를 최소화하여 어디서든 실행 가능
- **격리성**: 프로세스 단위의 격리를 통해 독립적인 실행 환경 제공
- **확장성**: 마이크로서비스 아키텍처에 적합하며 손쉬운 확장이 가능

<br />

### 컨테이너 기술의 장점
1. **마이크로서비스 아키텍처(MSA) 지원**  
   - 컨테이너는 독립적인 마이크로서비스 배포에 최적화됨  
   - 개발/운영 환경 차이를 최소화하여 DevOps에 적합

2. **클라우드 네이티브 환경과의 궁합**  
   - AWS, GCP, Azure 등 대부분의 클라우드 서비스에서 컨테이너 지원  
   - Kubernetes와 함께 사용하면 대규모 트래픽에도 유연한 확장 가능

3. **CI/CD 자동화 및 DevOps 친화적**  
   - 코드 변경 사항을 쉽게 컨테이너화하여 빠르게 배포 가능  
   - 테스트/배포 자동화가 쉬워지고, 롤백도 간편

<br />

### 마이크로서비스 아키텍처와 컨테이너 기술
컨테이너 기술은 각 마이크로서비스를 독립적인 컨테이너로 패키징함으로써, 개발, 배포, 스케일링의 유연성을 크게 향상시킴

1. 빠른 배포: 컨테이너의 경량성으로 인해 배포 시간이 크게 단축
2. 격리된 환경: 각 마이크로서비스는 독립적으로 운영되어 상호 간섭을 최소화
3. 리소스 효율성: 필요한 리소스만을 할당하여 효율적인 자원 관리가 가능

**가상화 방식과의 차이점**:
1. 오버헤드 감소: 컨테이너는 전체 OS를 포함하지 않아 가상 머신보다 오버헤드가 적음
2. 빠른 시작 시간: 컨테이너는 초 단위로 시작되는 반면, 가상 머신은 분 단위의 시간이 필요

---

<br />

## 4. 컨테이너 보안 고려사항

컨테이너는 가상 머신보다 보안성이 약할 수 있기 때문에 다음과 같은 요소를 고려해야 함.

| **보안 요소** | **설명** |
|--------------|----------|
| **네트워크 분리** | 컨테이너 간의 네트워크를 격리하여 보안 강화 |
| **이미지 서명 및 검증** | 신뢰할 수 있는 컨테이너 이미지만 실행 |
| **최소 권한 실행** | 컨테이너를 root 권한 없이 실행하여 보안 취약점 방지 |
| **취약점 스캐닝** | 실행 전에 이미지 취약점을 점검 (Trivy, Clair 등 사용) |
| **런타임 보안 모니터링** | 컨테이너 실행 중 이상 징후 감지 (Falco, Sysdig 사용) |

---

<br />

## 5. 컨테이너의 미래

1. **서버리스 컨테이너 (FaaS, Function as a Service)**
   - AWS Lambda, Google Cloud Run처럼 컨테이너를 함수 단위로 실행하는 방식 확산

2. **WASM(WebAssembly) 기반 컨테이너**
   - WebAssembly를 이용해 더 가볍고 안전한 실행 환경 제공

3. **보안 강화된 컨테이너 기술**
   - Kata Containers, gVisor 같은 격리 강화 기술 등장
